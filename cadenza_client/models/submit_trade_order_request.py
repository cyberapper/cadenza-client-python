# coding: utf-8

"""
    Algo724 Cadenza Fermata API

    OpenAPI Specification for Algo724 Cadenza Fermata API  ## API Resources - <a href=\"/postman-collection.json\" download=\"cadenza-postman-collection.json\">Download Postman Collection</a>

    The version of the OpenAPI document: 3.0.1
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""  # noqa: E501


from __future__ import annotations
import pprint
import re  # noqa: F401
import json

from pydantic import BaseModel, ConfigDict, Field, StrictBool, StrictInt, StrictStr, field_validator
from typing import Any, ClassVar, Dict, List, Optional
from typing_extensions import Annotated
from uuid import UUID
from cadenza_client.models.order_quantity_type import OrderQuantityType
from cadenza_client.models.order_side import OrderSide
from cadenza_client.models.order_type import OrderType
from cadenza_client.models.quantity_rounding import QuantityRounding
from cadenza_client.models.time_in_force import TimeInForce
from typing import Optional, Set
from typing_extensions import Self

class SubmitTradeOrderRequest(BaseModel):
    """
    SubmitTradeOrderRequest
    """ # noqa: E501
    trading_account_id: UUID = Field(description="UUID string", alias="tradingAccountId")
    instrument_id: StrictStr = Field(description="Instrument ID. {venue}:{symbol}", alias="instrumentId")
    idempotency_key: Optional[StrictStr] = Field(default=None, description="Alias of clientOrderId Idempotency key is used to ensure that the same request is not processed more than once. If the same request is received again, the server will return the same response as the first time.", alias="idempotencyKey")
    client_order_id: Optional[StrictStr] = Field(default=None, description="Client order ID, will be used as the idempotency key of the request, same of the idempotency key in the header. If not provided, a random string will be generated.", alias="clientOrderId")
    order_side: OrderSide = Field(alias="orderSide")
    order_type: OrderType = Field(alias="orderType")
    limit_price: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Decimal value as string to preserve precision", alias="limitPrice")
    stop_price: Optional[Annotated[str, Field(strict=True)]] = Field(default=None, description="Decimal value as string to preserve precision", alias="stopPrice")
    quantity: Annotated[str, Field(strict=True)] = Field(description="Decimal value as string to preserve precision")
    quantity_type: Optional[OrderQuantityType] = Field(default=None, alias="quantityType")
    quantity_rounding: Optional[QuantityRounding] = Field(default=QuantityRounding.EMPTY, alias="quantityRounding")
    position_id: Optional[UUID] = Field(default=None, description="UUID string", alias="positionId")
    time_in_force: Optional[TimeInForce] = Field(default=None, alias="timeInForce")
    expire_at: Optional[StrictInt] = Field(default=None, description="Unix timestamp in milliseconds", alias="expireAt")
    quote_id: Optional[UUID] = Field(default=None, description="UUID string", alias="quoteId")
    leverage: Optional[StrictInt] = Field(default=None, description="Leverage")
    await_closed: Optional[StrictBool] = Field(default=False, description="If true, the API will wait up to 1 second for the order to reach a closed/finalized state (FILLED, REJECTED, EXPIRED, CANCELLED) before responding. If false or omitted, returns immediately with the initial order state. Useful for market orders that typically fill immediately. ", alias="awaitClosed")
    __properties: ClassVar[List[str]] = ["tradingAccountId", "instrumentId", "idempotencyKey", "clientOrderId", "orderSide", "orderType", "limitPrice", "stopPrice", "quantity", "quantityType", "quantityRounding", "positionId", "timeInForce", "expireAt", "quoteId", "leverage", "awaitClosed"]

    @field_validator('limit_price')
    def limit_price_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^-?\d+(\.\d+)?$", value):
            raise ValueError(r"must validate the regular expression /^-?\d+(\.\d+)?$/")
        return value

    @field_validator('stop_price')
    def stop_price_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if value is None:
            return value

        if not re.match(r"^-?\d+(\.\d+)?$", value):
            raise ValueError(r"must validate the regular expression /^-?\d+(\.\d+)?$/")
        return value

    @field_validator('quantity')
    def quantity_validate_regular_expression(cls, value):
        """Validates the regular expression"""
        if not re.match(r"^-?\d+(\.\d+)?$", value):
            raise ValueError(r"must validate the regular expression /^-?\d+(\.\d+)?$/")
        return value

    model_config = ConfigDict(
        populate_by_name=True,
        validate_assignment=True,
        protected_namespaces=(),
    )


    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.model_dump(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        # TODO: pydantic v2: use .model_dump_json(by_alias=True, exclude_unset=True) instead
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Optional[Self]:
        """Create an instance of SubmitTradeOrderRequest from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self) -> Dict[str, Any]:
        """Return the dictionary representation of the model using alias.

        This has the following differences from calling pydantic's
        `self.model_dump(by_alias=True)`:

        * `None` is only added to the output dict for nullable fields that
          were set at model initialization. Other fields with value `None`
          are ignored.
        """
        excluded_fields: Set[str] = set([
        ])

        _dict = self.model_dump(
            by_alias=True,
            exclude=excluded_fields,
            exclude_none=True,
        )
        return _dict

    @classmethod
    def from_dict(cls, obj: Optional[Dict[str, Any]]) -> Optional[Self]:
        """Create an instance of SubmitTradeOrderRequest from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return cls.model_validate(obj)

        _obj = cls.model_validate({
            "tradingAccountId": obj.get("tradingAccountId"),
            "instrumentId": obj.get("instrumentId"),
            "idempotencyKey": obj.get("idempotencyKey"),
            "clientOrderId": obj.get("clientOrderId"),
            "orderSide": obj.get("orderSide"),
            "orderType": obj.get("orderType"),
            "limitPrice": obj.get("limitPrice"),
            "stopPrice": obj.get("stopPrice"),
            "quantity": obj.get("quantity"),
            "quantityType": obj.get("quantityType"),
            "quantityRounding": obj.get("quantityRounding") if obj.get("quantityRounding") is not None else QuantityRounding.EMPTY,
            "positionId": obj.get("positionId"),
            "timeInForce": obj.get("timeInForce"),
            "expireAt": obj.get("expireAt"),
            "quoteId": obj.get("quoteId"),
            "leverage": obj.get("leverage"),
            "awaitClosed": obj.get("awaitClosed") if obj.get("awaitClosed") is not None else False
        })
        return _obj


